## 물리적 데이터베이스 설계

보조 기억 장치에 어떻게 데이터를 저장할까?

*보조 기억 장치

블록 단위로 데이터를 저장해두어 이후 주기억 장치에서 데이터를 읽음
데이터가 변경된 경우 블록들을 디스크에 다시 기록(write)

[과거] 저장 장치 계층 구조

주기억 장치 - 디스크 - 테이프 (위-아래)

### 자기 디스크

- 여러개의 판으로 이루어짐
- 각 면마다 디스크 헤드가 있음(위 아래)
- 각 판은 트랙(동심원)과 섹터(나눈 영역)로 구분, 같은 트랙들 = 실린더
이때 실린더는 여러 파일들을 헤드를 움직이지 않고 읽을 수 있음
- 정보는 디스크 표면 상의 트랙을 따라 저장
- 디스크에서 임의의 블록 읽어오거나 기록하는데 걸리는 시간 
= 탐구 시간/헤드가 움직이는 시간(seek time) + 회전 지연 시간(rotational delay) + 전송 시간(transfer time)

### 버퍼관리와 운영 체제

매번 하드디스크에 접근하지 않기 위해 메모리에 저장을 해둠

- 운영체제 입장이서는 흔히 사용되는 LRU 알고리즘을 사용하지만 DBMS 입장에서는 optimal 하지 않은 경우가 있음

### 레코드 배치

- 애트리뷰트의 크기 가변/고정 길이의 필드 → 연관된 필드가 모여 가변/고정 레코드 생성
- 한 파일에 속하는 블록들이 반드시 인접해 있을 필요는X
- BLOB(Binary Large Object) - 이미지, 동영상 등 대규모 데이터
- 채우기 인수(fill factor) - 한 블록의 몇 % 채울 것인가. 100% 채울 필요 X
이는 나중에 레코드가 삽입될 대 기존 레코드들 이동하는 가능성 줄임
- 고정 길이 레코드 → 관리가 용이
레코드 크기를 알면  특정 위치(i)의 레코드 읽는데 용이
이때 레코드를 삭제한다고 하면 shift 형식으로 여러 개 레코드 이동 or 맨 뒤 레코드를 채우는 형식으로 한 개의 레코드 이동
- 파일 내 클러스터링(intra-file clustering) - 군집
함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아둠

### 파일 조직

**히프 파일(heap file) - 비순서 파일**

레코드들의 입력 순서대로 저장
”append”로 가장 끝에 새로운 레코드 첨부/삽입

검색 시 모든 레코드들을 순차적으로 접근해야 함. 레코드 찾은 후 삭제 히 삭제된 레코드가 차지하던 공간을 재사용하지 않음
일정 시기가 되면 다시 재조직/재구성 해 compact하게 만들어줘야 함

특정 레코드를 검색하는 경우에는 히프 파일이 비효율적 → b개의 블록이 있을 시 평균적으로 b/2개의 블록 읽어야함

⇒ 삽입 이외의 모든 연산에 비효율적

**순차 파일(sequential file)**

하나 이상의 필드 값에 따라 순서대로 저장(sorting)
레코드의 **탐색 키(search key)** 값의 순서에 따라 저장 → 정렬에 사용되는 필드

이진 탐색을 이용해서 탐색 가능, 조건에 따라 전체 탐색일 경우도 있음

⇒ 탐색 키를 기반으로 탐색하는 것 외에 모든 연산에 비효율적

**인덱스된 순차 파일(indexed sequential file)**

**직접 파일(hash file)**

⇒ 실제 파일을 관리할 때는 “인덱스” 사용

### 인덱스

단일 단계 인덱스 - 엔트리 <탐색 키, 레코드에 대한 포인터>, 엔트리들은 탐색 키 값의 오름차순 정렬

인덱스는 데이터 파일과 별도의 파일에 저장
인덱스 크기는 데이터 파일 크기에 비해 훨씬 작음
하나의 파일에 여러개의 인덱스 파일이 존재할 수 있음(속성에 따라 다른 인덱스 파일 존재 가능)

- 기본 인덱스(primary index) - 탐색 키를 이용해 인덱스를 만든 것
    
    기본 인덱스는 흔히 희소 인덱스로 유지 가능(대표되는 값들 몇개만 뽑아서 인덱스 생성)
    ↔ 밀집 인덱스는 모든 경우의 값들을 인덱스 테이블에 생성
    
- 클러스터링 인덱스(clustering index) - 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함
    
    범위 질의에 유용
    
- 보조 인덱스(secondary index) - 탐색 키 값에 따라 정렬되지 않은 데이터 파일

다단계 인덱스 - 단일 단계 인덱스에 대해서 다시 인덱스 정의 가능

인덱스가 하나의 블록 안으로 들어가는 단계까지 반복해서 인덱스의 인덱스를 만듬

가장 상위 단계 인덱스 = 마스터 인덱스(master index)
마스터 인덱스는 한 블록으로 이루어지기 때문에 주기억 장치에 상주 가능
다단계 인덱스 = B+ 트리(balenced tree)

레코드가 삽입 or 삭제될 때 인덱스들이 수정이 될 수 있음 = index maintenance overhead

이때 트리의 형태가 편향된 트리일 수 있음, depth가 다른 경우 (skewed tree)

**SQL 인덱스 정의문**

CREATE TABLE에서 PK절로 명시한 속성에 대해서는 DBMS가 자동적으로 기본 인덱스 생성

```sql
CREATE INDEX [인덱스 이름] ON [테이블 이름(속성들)];
```

인덱스 장점과 단점

인덱스를 통해 검색 속도 향상 but 삽입, 삭제, 수정 연산의 속도는 저하(인덱스 수정 필요)

소수의 레코드들을 수정하거나 삭제하는 연산의 속도는 향상

### B+ TREE

split & merge를 통해 키 값이 삽입/삭제 될때마다 balance를 맞춰주며 트리를 형성
