## 트랜잭션

(transaction) 

동시에 다수의 사용자들이 사용
→ 동시성 제어(concurrency control)

동시에 수행되는 트랜잭션들이 DB에 미치는 영향은 이들을 순차적으로 수행했을 때와 같도록
다수 사용자가 DB를 동시에 접근하도록 허용하면서 DB의 일관성 유지

→ 회복(recovery)

DB를 갱신하는 도중 시스템이 고장 나도 데이터베이스의 일관성 유지
어떤 상황에서도 데이터를 잃어버리지 않는 것을 보장

데이터베이스를 갱신하는 중 컴퓨터 시스템 다운

→ “**로그(log)**” 유지 (어디까지 수정되었는가)

기본적으로 각각의 SQL문이 하나의 트랜잭션으로 취급

### 트랜잭션 특성 ACID

- 원자성(**A**tomicity)
    
    한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)
    
    완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행(redo)로 원자성 보장
    부분적으로 DB를 갱신한 트랜잭션의 영향을 취소(undo)로 원자성 보장
    
- 일관성(**C**onsistency)
    
    어떤 트랜잭션이 수행되기 전에 DB가 일관된 상태를 가졌다면 트랜잭션 수행 후에 DB는 또 다른 일관된 상태를 가짐
    
    트랜잭션이 수행되기 전이나, 수행된 후의 상태 즉 일관적 상태로만 만듬
    (트랜잭션을 수행하는 상태에는 불일치 상태가 있을 수 있음)
    
- 고립성(**I**solation)
    
    한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 다른 트랜잭션 접근X
    
- 지속성(**D**urability)
    
    한번 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
    

**Commit** - 트랜잭션의 **완료**

트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨

“COMMIT WORK”

**Abort** - 트랜잭션의 **철회**

트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우, 원자성을 보장하기 위해 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림

“ROLLBACK WORK” ⇒ undo

### 동시성 제어

대부분의 DBMS들은 다수 사용자용으로 여러 사용자들이 동시에 동일한 테이블 접근 가능
따라서 동시성 제어 기법은 트랜잭션들 간의 간섭,충돌이 생기지 않도록 함

- 직렬 스케줄(serial schedule)
    
    여러 트랜잭션들의 집합을 한 번에 한 트랜잭션 씩 차례대로 수행
    
- 비직렬 스케줄(non-serial schedule)
    
    여러 트랜잭션들을 동시에 수행
    
- 직렬가능/직렬성(serializable)
    
    비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등
    serial하게 하지 않았지만 serial과 같은 결과가 나옴
    

데이터베이스 연산

- Input(x): 데이터베이스 → 주기억 장치의 버퍼로 읽기
- output(x): 주 기억 장치 → 데이터베이스(디스크)에 기록
- write(x): 프로그램 변수 → 주기억 장치에 기록
- read(x): 프로그램 변수 → 주기억 장치로부터 값 복사

동시성 제어 문제

- 갱신 손실(lost update)
- 오손 데이터 읽기(dirty read)
    
    완료되지 않은 트랜잭션 갱신 데이터 읽는 것
    
- 반복할 수 없는 읽기(unrepeatable read)
    
    한 트랜잭션이 동일한 데이터 두 번 읽을 때 서로 다른 값 읽은 것
    

로킹(locking)

동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해 널리 사용

로크(lock) - DB내 각 데이터 항목과 연관된 하나의 변수
로크테이블(lock table) - 수행 시작하여 데이터 항목 접근할 때마다 요청한 로크 관한 정보

트랜잭션이 갱신을 목적으로 데이터 항목 접근 → 독점 로크(X-lock, eXclusive lock)
트랜잭션이 읽을 목적으로 데이터 항목을 접근 → 공유 로크(S-lock, Shared lock)

접근 끝난 후에는 로크를 해제(unlock)
언제하는가? 병렬성을 높이기 위해 필요 없어질 때 바로 unlock, but 너무 즉시 할 경우 동시성 제어 문제가 발생할 수도 있기 때문에 commit이 될 때 까지 유지했다가 unlock하는게 안전

⇒ 배타적인 리소스에 대해서 충돌은 방지할 수 있지만, 동시성 제어를 완벽하게 하는 것 X

2단계 로킹 프로토콜(2-phase locking protocol)

로크를 요청하는 것과 로크를 해제하는 것이 2 단계로 이루어짐
로크 확장 단계가 지난 후에 로크 수축 단계로 진행(로크를 걸어야 하는 것들 모두 로크한 후 해제 시작)

- 1단계: 로크 확장 단계 - 로크 걸 시 1개라도 로크를 해제할 수 없음
- 2단계: 로크 수축 단계 - 하나씩 or 한꺼번에 로크 해제

데드록(deadlock)

두 개 이상의 트랜잭션이 서로의 자원을 요청하는 상황

해결하기 위해서는 “victim(희생양)”을 정해야 함

다중 로크 단위(multiple granularity)

데이터베이스 - 릴레이션 - 디스크 블록(페이지) - 레코드(튜플)

팬텀 문제(phantom problem)

현재 존재하지 않는 튜플에 관해서는 lock을 걸 수 없다 !
따라서 한 트랜잭션에서 검색 결과가 다르게 나오게 됨

⇒ 릴레이션 자체가 아닌 인덱스에 lock을 걸어 해결

### 회복

트랜잭션을 수행하던 도중 시스템 다운 시 어디까지 반영이 되어있는가?

“로그” 데이터베이스의 모든 업데이트를 별도의 로그에 관리하기

데이터를 저장하는 디스크와 로그를 저장하는 디스크는 동일. 이때 로그 저장 디스크는 안정성을 높이는 방법을 생각.

“안전 저장 장치(stable storage)” ⇒ redundant 중복 저장(두 개 이상이 동시에 고장날 확률 적기 때문)
