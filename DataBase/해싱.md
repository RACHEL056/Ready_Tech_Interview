## 데이터베이스의 저장과 접근: 해싱

### 해싱(hashing)

다른 레코드의 참조 없이 목표 레코드의 접근을 직접 지원(직접 화일)

키(key) 값과 레코드 주소(address) 사이의 매핑 관계를 함수로 설정
⇒ 키 값으로부터 레코드 주소를 계산(키 → 주소)

**(1) 버킷 해싱**

버킷(bucket) - 하나의 주소를 가지면서 하나 이상의 레코드를 저장할 수 있는 파일의 한 구역

한 버킷에는 여러개의 레코드를 가짐
키 → 버킷 주소

이때 같은 버킷이 있는 레코드들 - 동거자(synonym)

문제: 충돌(collision) → 상이한 레코드들을 같은 주소로 변환

해시함수를 어떻게 만드느냐에 따라 특정한 주소에 레코드들이 몰리게 될 경우 버킷 만원
→ 오버플로 버킷
이는 아무리 해시 함수를 잘 만들어도 키에 따라 편향될 위험

**(2) 확장성 해싱(extendible hashing)**

충돌에 대처하기 위한 기법, 레코드 검색은 최대 2번의 디스크 접근만 필요
flexible한 방법

모조키(pseudokey)

확장성 해싱 함수 - 키 값을  일정 길이의 비트 스트링로 간주 → pseudokey로 변환
pseudokey의 처음 d 비트를 디렉터리의 인덱스로 사용

디렉터리(directory)

헤더에 현재의 디렉터리 깊이 d를 유지
d: 전역 깊이(global depth)
2^d만큼의 버킷을 가질 수 있음

버킷

헤더에 현재의 버킷 깊이 p를 유지
p: 지역 깊이(local depth)

버킷이 다 찰 경우 d값을 증가해 새로운 버킷을 할당받아 레코드 저장

⇒ 디렉터리 오버플로/언더플로 발생 가능
