## 뷰와 시스템 카탈로그

뷰 = 유도된 릴레이션(derived relation), virtual relation
가상으로 정의한 SQL문

개별 사용자들만의 뷰를 제공해준다 ⇒ 보안 메카니즘
데이터 독립성을 높일 수 있음

시스템 카탈로그(메타 데이터) = 시스템내의 객체(릴레이션, 뷰, 인덱스, 사용자, 접근 권한)에 관한 정보 포함

### 뷰

기본 릴레이션에 대한 SELECT문의 형태로 정의
데이터를 검색하거나 갱신할 수 있는 “동적인 창(dynamic window)” 역할

*스냅샷(snapshot) - 어느 시점에 SELECT문의 결과를 기본 릴레이션 형태로 저장
정의하는 시점에 릴레이션 내용이 반영

↔ 뷰와 같은 경우 정의는 되어있지만 실행 X 뷰를 이용해 연산을 요청할 때 실행됨

```sql
CREATE VIEW 뷰이름 [(애트리뷰트(들))]
AS SELECT문
[WITH CHECK OPTION];
```

뷰의 장점

- 복잡한 질의를 간단하게 표현할 수 있게 함
    
    아래 두 SQL문은 같은 결과
    
    ```sql
    SELECT E.EMPNAME, E.SALARY
    FROM EMPLOYEE E, DEPARTMENT D
    WHERE D.DEPTNAME = '기획'
        AND D.DEPTNO = E.DNO
        AND E.TITLE = '부장';
    ```
    
    ```sql
    SELECT EMPNAME, SALARY
    FROM EMP_PLANNING
    WHERE TITLE = '부장';
    ```
    
- 데이터 무결성을 보장하는데 활용
뷰는 가상의 릴레이션인데 업데이트가 가능한가? 모든 뷰의 업데이트는 베이스 릴레이션에 반영
이때, 뷰를 정의하는 SELECT문의 WHERE절의 기준에 맞지 않게 되면 뷰 내용 사라짐
    
    ⇒ 이를 허용하지 않을 시 “WITH CHECK OPTION”
    
- 데이터 독립성을 보장함
    
    데이터베이스의 구조가 바뀌어도 기존의 질의를 다시 작성할 필요성 줄일 수 있음
    
- 데이터 보안 기능 제공
    
    기본 릴레이션에 직접 접근할 수 있는 권한을 부여하지 않고 뷰를 통해 데이터 접근
    
- 동일한 데이터에 대한 여러 가지 뷰를 제공
    
    특정한 기준에 따라 데이터 접근
    

뷰의 갱신

뷰에 대한 갱신도 기본 릴레이션에 대한 갱신으로 변환

```sql
INSERT INTO EMP_DNO3
VALUES (4293, '김정수','사원');

=> 이와 같이 변경이 되어서 베이스 릴레이션에 저장됨, 누락된 값들은 NULL
INSERT INTO EMPLOYEE
VALUES(4293, '김정수', '사원',,,);
```

그렇다면 두 릴레이션의 조인으로 생성된 뷰는?

PK가 있어야 insert 가능 ! 논리적으로 삽입할 수 있는 경우에만 허용
따라서 보통은 조인되어 만들어진 뷰는 삽입 허용X

갱신이 불가능한 뷰

- 한 릴레이션 위에서 정의되었으나 기본 키가 포함되지 않은 뷰
- 기본 릴레이션의 애트리뷰트들 중 뷰에 포함되지 않은 애트리뷰트에 NOT NULL이 지정
- 집단 함수가 포함된 뷰
- 조인으로 정의된 뷰

### 시스템 카탈로그

“메타데이터” 데이터에 관한 데이터
데이터 사전(data dictionalry) or 시스템 테이블 이라고도 부름

시스템 카탈로그 질의 처리 활용

- SELECT문이 문법적으로 정확한가?
- 참조하는 릴레이션이 DB에 존재하는가
- SELECT절에 열거된 애트리뷰트와 WHERE절에서 조건에 사용된 애트리뷰트가 존재하는가
- 데이터 타입 확인
- 사용자가 SELECT 즉 검색할 수 있는 권한 있는가 확인
- 인덱스가 정의되어 있는지 확인
- 인덱스 존재 시, 두 인덱스 중 조건에 만족하는 튜플 수가 적은 것 선택
- 한 릴레이션의 전체 튜플 수와 그 릴레이션에 정의된 각 인덱스에 존재하는 상이한 값 개수 유지할 경우 어느 인덱스 사용하는 것이 유리한가 예상

시스템 카탈로그의 갱신

어떤 사용자도 시스템 카탈로그를 직접 갱신할 수 없음
