## 릴레이션 정규화

데이터베이스 설계에는 데이터 중복을 야기해 “갱신 이상(update anomaly)” 유발

이러한 함수적 종속성을 제거해 이상 현상을 감소시킴

### 갱신 이상

- 수정 이상(modification anomaly)
    
    반복된 데이터 중 일부만 수정해 데이터 불일치 발생
    
- 삽입 이상(insertion anomaly)
    
    부수적인 데이터를 저장해야 삽입이 가능한 상황
    
- 삭제 이상(deletion anomaly)
    
    유용한 정보를 함께 삭제하지 않고는 어떤 정보 삭제하는 것이 불가능
    

### ⇒ 문제

- 정보의 중복 - 동일한 튜플들이 존재하면 저장 공간이 낭비 됨
- 수정 이상 - 일부 튜플에서만 데이터를 변경하면 데이터베이스가 불일치 상태 빠짐(inconsistent)
- 삽입 이상 - 원하는 정보를 입력할 수 없음
- 삭제 이상 - 튜플 삭제 시 지우고 싶지 않은 튜플 속 정보도 삭제됨

### ⇒ 해결

릴레이션 분해 = decompose

하나의 릴레이션을 두 개 이상 릴레이션으로 나누는 것
이 때, 분해된 릴레이션들로부터 원래의 릴레이션을 다시 구할 수 있음을 보장

“함수 종속성”에 기준에 따라 분해

### 함수적 종속성

릴레이션의 애트리뷰트 간의 관계 ⇒ 특정 인스턴스에 대한 주장 X 스키마 자체
함수 관계

- 결정자(determinant)
주어진 릴레이션에서 다른 애트리뷰트(혹은 집합)를 고유하게 결정하는 하나 이상의 애트리뷰트
    
    A → B : A가 B를 결정한다(A는 B의 결정자)
    

따라서 만일 애트리뷰트 A가 B를 결정한다면 B가 A에 함수적으로 종속한다고 함

- 완전 함수적 종속(FFD: Full Functional Dependency)
    
    애트리뷰트 A가 복합 애트리뷰트 일 때 발생
    
    ↔ 부분 함수적 종속
    
- 이행적 함수적 종속성(transitive FD)
    
    A → B, B → C ⇒ A → C
    

### 릴레이션 분해

중복이 감소되고 갱신 이상이 줄어드는 장점 but 잠재적인 문제(조인, 재구성 못할 수도)

- 무손실 분해(lossless decomposition)
    
    이때 손실은 “정보의 손실”
    분해된 두 릴레이션을 조인하면 원래의 릴레이션에 들어 있는 정보 완전히 얻을 수 있음

### 제 1 정규형

모든 릴레이션은 제 1 정규형이다 ! → 모든 애트리뷰트가 원자값만을 갖는 것
릴레이션의 모든 애트리뷰트에 반복그룹(repeating group)이 나타나지 않아야 함

### 제 2 정규형

제 1 정규형을 만족하면서, 기본키에 완전하게 함수적으로 종속하는 것(부분 함수적 종속성을 제거)

⇒ 이상이 발생 why? “이행적 종속성”이 존재하기 때문

### 제 3 정규형

제 2 정규형을 만족하면서, 이행적 종속 관계가 없는 것

⇒ 문제발생 경우: 키가 아닌 애트리뷰트로 다른 애트리뷰트 값이 결정되는 경우

### BCNF

제 3 정규형 이면서, 모든 결정자가 후보키인 경우

### 역정규화(denormalization)

정규화 단계가 진행될수록 중복이 감소되고 갱신 이상도 감소
= 높은 정규형을 갖는 것이 최적의 방법은 아니다

why? 정규화를 하면 조인을 해야하기 때문

따라서 낮은 정규형으로 돌아가서 성능을 더 높임
